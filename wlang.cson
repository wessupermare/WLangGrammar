{
	# A lot of help from https://github.com/atom/language-csharp/blob/master/grammars/csharp.cson
	scopeName = 'source.wlang';
	fileTypes = ( 'w' );
	foldingStartMarker = '\[\s*$';
	foldingStopMarker = '^\s*\]';
	patterns = (
	{
		name = 'comment.line.question-mark.wlang';
		begin = '\?';
		end = '(?=$)';
	},
	{
		name = 'comment.block.wlang';
		begin = '\{';
		end = '\}';
	},
	{
		name = 'constant.numeric.wlang';
		match = '\b\d+\b';
	},
	{
		name = 'constant.language.boolean.true.wlang';
		match = '(?i)\bTrue\b';
	},
	{
		name = 'constant.language.boolean.false.wlang';
		match = '(?i)\bFalse\b';
	},
	{
		name = 'meta.function.wlang';
		begin = '(?i)\b(?:(Public)\s)?(Func)\s([a-zA-Z][_a-zA-Z0-9]*)\s*\[';
		begincaptures = {
			1 = { name = 'storage.type.function.wlang'; };
			2 = { name = 'storage.modifier.access.public.wlang' };
			3 = { name = 'entity.name.function.wlang'; };
		};
		end = '\]';
	},
	{ name = 'keyword.control.break.wlang'; match = '(?i)\bEscape\b'; },
	{ name = 'keyword.control.return.wlang'; match = '(?i)\bReturn\b'; },
	{ name = 'keyword.control.if.wlang'; match = '(?i)\bIf\b'; },
	{ name = 'keyword.control.loop.wlang'; match = '(?i)\bRepeat\b'; },
	{ name = 'keyword.operator.logical.wlang'; match = '(?i)\b(?:And|Or|Not)\b'; },
	{ name = 'keyword.operator.bitwise.wlang'; match = '(?i)&|\||\^'; },
	{ name = 'keyword.operator.arithmetic.wlang'; match = '%|\*|\/|-|\+|\\'; },
	{ name = 'keyword.operator.comparison.wlang'; match = '='; },
	{ name = 'keyword.operator.relational.wlang'; match = '[<>]=?'; },
	{
		name = 'string.quoted.double.wlang';
		begin = '"';
		end = '"';
		patterns = ({
			name = 'constant.character.escape.wlang';
			patterns = ({ include = '#escaped-char'; });
		});
	},
	{
		name = 'string.quoted.single.wlang';
		begin = '\'';
		end = '\'';
	},
	{
		match = '(?i)\b(args)(?:\.|\b)';
		captures = {
			1 = { name = 'variable.parameter.wlang'; };
		};
	},
	{
		name = 'variable.language.iterator.wlang';
		match = '\$';
	},
	{
		name = 'variable.language.counter.wlang';
		match = '\#';
	},
	{
		match = '(?i)\bItem\s([a-zA-Z][_a-zA-Z0-9]*)(?:\s(=))\b';
		captures = {
			1 = { name = 'variable.other.wlang'; };
			2 = { name = 'keyword.operator.assignment.wlang'; };
		};
	},
	{
		name = 'meta.import.wlang';
		match = '(?i)^(REF)\s\'[a-zA-Z][_a-zA-Z0-9]*\'(?:,\s\'[a-zA-Z][_a-zA-Z0-9]*)\'*(?:\s(FROM)\s\'[a-zA-Z][_a-zA-Z0-9]*\')?$';
		captures = {
			1 = { name = 'keyword.other.import.wlang'; };
			2 = { name = 'keyword.other.from.wlang'; };
		};
	},
	{
		name = 'meta.projection.wlang';
		begin = '(<\[)';
		begincaptures = { 1 = { name = 'keyword.other.projection.begin.wlang'; }; };
		end = '(\]>)';
		endcaptures = { 1 = { name = 'keyword.other.projection.end.wlang'; }; };
		patterns = ({ name = 'keyword.operator.project.wlang'; match = '=>'; });
	},
	);
	repository = {
		escaped-char = { match = '\\.'; };
		identifier = { match = '[a-zA-Z][_a-zA-Z0-9]*'; };
	};
}
